//! # DBus interface proxies for: `org.a11y.atspi.Event.Object`, `org.a11y.atspi.Event.Window`, `org.a11y.atspi.Event.Mouse`, `org.a11y.atspi.Event.Keyboard`, `org.a11y.atspi.Event.Terminal`, `org.a11y.atspi.Event.Document`, `org.a11y.atspi.Event.Focus`
//!
//! This code was generated by `zbus-xmlgen` `2.0.1` from DBus introspection data.
//! Source: `Event.xml`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the
//! [Writing a client proxy](https://dbus.pages.freedesktop.org/zbus/client.html)
//! section of the zbus documentation.
//!

pub mod document;
pub mod focus;
pub mod keyboard;
pub mod mouse;
pub mod object;
pub mod terminal;
pub mod window;

use std::{collections::HashMap, sync::Arc};

use serde::{Deserialize, Serialize};
use zbus::{
    names::{InterfaceName, MemberName, OwnedUniqueName, UniqueName},
    zvariant::{self, OwnedObjectPath, OwnedValue, Signature, Type, Value},
    Message,
};

use crate::{cache::CacheItem, connection, AtspiError};

#[derive(Debug, Serialize, Deserialize)]
pub struct EventBody<'a, T> {
    #[serde(rename = "type")]
    pub kind: T,
    pub detail1: i32,
    pub detail2: i32,
    #[serde(borrow)]
    pub any_data: Value<'a>,
    #[serde(borrow)]
    pub properties: HashMap<&'a str, Value<'a>>,
}

impl<T> Type for EventBody<'_, T> {
    fn signature() -> Signature<'static> {
        <(&str, i32, i32, Value, HashMap<&str, Value>)>::signature()
    }
}

// Signature:  "siiv(so)",
#[derive(Debug, Serialize, Deserialize, Type)]
pub struct EventBodyQT {
    #[serde(rename = "type")]
    pub kind: String,
    pub detail1: i32,
    pub detail2: i32,
    pub any_data: OwnedValue,
    pub properties: (String, OwnedObjectPath),
}

// Signature (siiva{sv}),
#[derive(Clone, Debug, Serialize, Deserialize, Type)]
pub struct EventBodyOwned {
    #[serde(rename = "type")]
    pub kind: String,
    pub detail1: i32,
    pub detail2: i32,
    pub any_data: OwnedValue,
    pub properties: HashMap<String, OwnedValue>,
}

impl From<EventBodyQT> for EventBodyOwned {
    fn from(body: EventBodyQT) -> Self {
        let mut props = HashMap::new();
        props.insert(
            body.properties.0,
            Value::ObjectPath(body.properties.1.into_inner()).to_owned(),
        );
        Self {
            kind: body.kind,
            detail1: body.detail1,
            detail2: body.detail2,
            any_data: body.any_data,
            properties: props,
        }
    }
}

/// Encapsulates the various different accessibility bus signal types.
///
/// Assumes being non exhaustive to allow for future- or custom signals.
#[derive(Debug, Clone)]
#[non_exhaustive]
pub enum Event {
    /// Includes Atspi and Qspi events
    Atspi(AtspiEvent),
    /// Emitted when the ` Registry` interface on `org.a11y.atspi.Registry` becomes available.
    Available(AvailableEvent),
    /// Both `CacheAdd` and `CacheRemove` signals
    Cache(CacheEvent),

    /// Emitted on `KeystrokeListenerRegistered` and `KeystrokeListenerDeragistered
    /// `(souua(iisi)u(bbb)
    //  Device(DeviceEvent)

    /// Emitted on registry or deregristry of event listeners.,
    ///
    /// (eg. "Cache:AddAccessible:")
    Listener(EventListenerEvent),
}

#[derive(Debug, Clone)]
pub enum CacheEvent {
    Add(CacheAddEvent),
    Remove(CacheRemoveEvent),
}

/// Type that contains the `zbus::Message` for meta information and
/// the [`crate::cache::CacheItem`]
#[derive(Debug, Clone)]
pub struct CacheAddEvent {
    pub(crate) message: Arc<Message>,
    pub(crate) body: CacheItem,
}

impl CacheAddEvent {
    /// When an object in an application is added, this may evoke a `CacheAdd` event,
    /// this yields an [`crate::cache::CacheItem`]
    #[must_use]
    pub fn item(&self) -> &CacheItem {
        &self.body
    }

    /// When an object in an application is added, this may evoke a `CacheAdd` event,
    /// this yields an [`crate::cache::CacheItem`]
    /// Consumes the `CacheAdd` event.
    #[must_use]
    pub fn into_item(self) -> CacheItem {
        self.body
    }
}

#[derive(Debug, Clone)]
pub struct CacheRemoveEvent {
    pub(crate) message: Arc<Message>,
    pub(crate) body: Accessible,
}

impl CacheRemoveEvent {
    /// What `Accessible` is removed from the application state.
    /// A reference to the `Accessible`
    #[must_use]
    pub fn as_accessible(&self) -> &Accessible {
        &self.body
    }

    /// What `Accessible` is removed from the application state.
    /// Converts the event to an Accessible
    /// Consumes the cache remove event.
    #[must_use]
    pub fn into_accessible(self) -> Accessible {
        self.body
    }

    // pub fn as_iface_reusing_connection(&self, conn: &Connection) -> AccessibleProxy {
    //     let Accessible { name, path } = self.as_accessible();
    //     crate::accessible::new(&**conn, sender, path.into())
    // }
}

// TODO: Try to make borrowed versions work,
// check where the lifetimes of the borrow are tied to, see also: comment on `interface()` method
// in `DefaultEvent` impl
// then rename into Owned for this one.
/// Owned Accessible type
/// Emitted by `CacheRemove` and `Available`
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct Accessible {
    name: OwnedUniqueName,
    path: OwnedObjectPath,
}

#[test]
fn test_accessible_signature() {
    assert_eq!(Accessible::signature(), "(so)");
}

impl GenericEvent for CacheRemoveEvent {
    /// Bus message.
    #[must_use]
    fn message(&self) -> &Arc<Message> {
        &self.message
    }

    /// For now this returns the full interface name because the lifetimes in [`zbus_names`][zbus::names] are
    /// wrong such that the `&str` you can get from a
    /// [`zbus_names::InterfaceName`][zbus::names::InterfaceName] is tied to the lifetime of that
    /// name, not to the lifetime of the message as it should be. In future, this will return only
    /// the last component of the interface name (I.E. "Object" from
    /// "org.a11y.atspi.Event.Object").
    #[must_use]
    fn interface(&self) -> Option<InterfaceName<'_>> {
        self.message.interface()
    }

    /// Identifies this event's interface member name.
    #[must_use]
    fn member(&self) -> Option<MemberName<'_>> {
        self.message.member()
    }

    /// The object path to the object where the signal is emitted from.
    #[must_use]
    fn path(&self) -> std::option::Option<zbus::zvariant::OwnedObjectPath> {
        Some(OwnedObjectPath::from(self.message.path().unwrap()))
    }

    /// Identifies the `sender` of the event.
    /// # Errors
    /// - when deserializeing the header failed, or
    /// - When `zbus::get_field!` finds that 'sender' is an invalid field.
    fn sender(&self) -> Result<Option<zbus::names::UniqueName>, crate::AtspiError> {
        Ok(self.message.header()?.sender()?.cloned())
    }
}

impl GenericEvent for CacheAddEvent {
    /// Serialized bus message.
    #[must_use]
    fn message(&self) -> &Arc<Message> {
        &self.message
    }

    /// For now this returns the full interface name because the lifetimes in [`zbus_names`][zbus::names] are
    /// wrong such that the `&str` you can get from a
    /// [`zbus_names::InterfaceName`][zbus::names::InterfaceName] is tied to the lifetime of that
    /// name, not to the lifetime of the message as it should be. In future, this will return only
    /// the last component of the interface name (I.E. "Object" from
    /// "org.a11y.atspi.Event.Object").
    #[must_use]
    fn interface(&self) -> Option<InterfaceName<'_>> {
        self.message.interface()
    }

    /// Identifies this event's interface member name.
    #[must_use]
    fn member(&self) -> Option<MemberName<'_>> {
        self.message.member()
    }

    /// The object path to the object where the signal is emitted from.
    #[must_use]
    fn path(&self) -> std::option::Option<zbus::zvariant::OwnedObjectPath> {
        Some(OwnedObjectPath::from(self.message.path().unwrap()))
    }

    /// Identifies the `sender` of the event.
    /// # Errors
    /// - when deserializeing the header failed, or
    /// - When `zbus::get_field!` finds that 'sender' is an invalid field.
    fn sender(&self) -> Result<Option<zbus::names::UniqueName>, crate::AtspiError> {
        Ok(self.message.header()?.sender()?.cloned())
    }
}

impl TryFrom<Arc<Message>> for CacheRemoveEvent {
    type Error = AtspiError;

    fn try_from(message: Arc<Message>) -> Result<Self, Self::Error> {
        if message.member() != Some(MemberName::from_static_str("RemoveAccessible")?) {
            return Err(AtspiError::CacheVariantMismatch);
        };
        let body = message.body::<Accessible>()?;
        Ok(Self { message, body })
    }
}

impl TryFrom<Arc<Message>> for CacheAddEvent {
    type Error = AtspiError;

    fn try_from(message: Arc<Message>) -> Result<Self, Self::Error> {
        if message.member() != Some(MemberName::from_static_str("AddAccessible")?) {
            return Err(AtspiError::CacheVariantMismatch);
        };
        let body = message.body::<CacheItem>()?;
        Ok(Self { message, body })
    }
}

#[derive(Debug, Clone)]
pub struct AtspiEvent {
    pub(crate) message: Arc<Message>,
    pub(crate) body: EventBodyOwned,
}

impl TryFrom<Arc<Message>> for AtspiEvent {
    type Error = AtspiError;

    fn try_from(message: Arc<Message>) -> Result<Self, Self::Error> {
        let signature = message.body_signature()?;
        let body = if signature == connection::QSPI_EVENT {
            EventBodyOwned::from(message.body::<EventBodyQT>()?)
        } else {
            message.body::<EventBodyOwned>()?
        };
        Ok(Self { message, body })
    }
}

/// Signal type emitted by `EventListenerRegistered` and `EventListenerDeregistered` signals,
/// which belong to the `Registry` interface, implemented by the registry-daemon.
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct EventListener {
    pub bus_name: OwnedUniqueName,
    pub path: OwnedObjectPath,
}

#[test]
fn test_event_listener_signature() {
    assert_eq!(EventListener::signature(), "(ss)");
}

/// Encapsulates both `EventListener` events.
#[derive(Clone, Debug)]
pub enum EventListenerEvent {
    Registered(EventListenerRegisteredEvent),
    Deregistered(EventListenerDeregisteredEvent),
}

#[derive(Clone, Debug)]
pub struct EventListenerDeregisteredEvent {
    pub(crate) message: Arc<Message>,
    body: EventListener,
}

impl GenericEvent for EventListenerDeregisteredEvent {
    /// Bus message.
    #[must_use]
    fn message(&self) -> &Arc<Message> {
        &self.message
    }

    /// The interface that emitted the event.
    #[must_use]
    fn interface(&self) -> Option<InterfaceName<'_>> {
        self.message.interface()
    }

    /// Identifies this event interface's member name.
    #[must_use]
    fn member(&self) -> Option<MemberName<'_>> {
        self.message.member()
    }

    /// The object path to the object where the signal was emitted.
    #[must_use]
    fn path(&self) -> std::option::Option<zbus::zvariant::OwnedObjectPath> {
        Some(OwnedObjectPath::from(self.message.path().unwrap()))
    }

    /// Identifies the `sender` of the event.
    /// # Errors
    /// - when deserializeing the header failed, or
    /// - When `zbus::get_field!` finds that 'sender' is an invalid field.
    fn sender(&self) -> Result<Option<zbus::names::UniqueName>, crate::AtspiError> {
        Ok(self.message.header()?.sender()?.cloned())
    }
}

impl TryFrom<Arc<Message>> for EventListenerDeregisteredEvent {
    type Error = AtspiError;

    fn try_from(message: Arc<Message>) -> Result<Self, Self::Error> {
        if message.member() != Some(MemberName::from_static_str("EventListenerDeregistered")?) {
            return Err(AtspiError::MemberMatch("EventListenerDeregistered".to_string()));
        };
        let body = message.body::<EventListener>()?;
        Ok(Self { message, body })
    }
}

#[derive(Clone, Debug)]
pub struct EventListenerRegisteredEvent {
    pub(crate) message: Arc<Message>,
    body: EventListener,
}

impl TryFrom<Arc<Message>> for EventListenerRegisteredEvent {
    type Error = AtspiError;

    fn try_from(message: Arc<Message>) -> Result<Self, Self::Error> {
        if message.member() != Some(MemberName::from_static_str("EventListenerRegistered")?) {
            return Err(AtspiError::MemberMatch("EventListenerRegistered".to_string()));
        };
        let body = message.body::<EventListener>()?;
        Ok(Self { message, body })
    }
}

impl GenericEvent for EventListenerRegisteredEvent {
    /// Bus message.
    #[must_use]
    fn message(&self) -> &Arc<Message> {
        &self.message
    }

    /// The interface that emitted the event.
    #[must_use]
    fn interface(&self) -> Option<InterfaceName<'_>> {
        self.message.interface()
    }

    /// Identifies this event interface's member name.
    #[must_use]
    fn member(&self) -> Option<MemberName<'_>> {
        self.message.member()
    }

    /// The object path to the object where the signal was emitted.
    #[must_use]
    fn path(&self) -> std::option::Option<zbus::zvariant::OwnedObjectPath> {
        Some(OwnedObjectPath::from(self.message.path().unwrap()))
    }

    /// Identifies the `sender` of the event.
    /// # Errors
    /// - when deserializeing the header failed, or
    /// - When `zbus::get_field!` finds that 'sender' is an invalid field.
    fn sender(&self) -> Result<Option<zbus::names::UniqueName>, crate::AtspiError> {
        Ok(self.message.header()?.sender()?.cloned())
    }
}

/// An event that is emitted when the registry daemon has started.
#[derive(Clone, Debug)]
pub struct AvailableEvent {
    pub(crate) message: Arc<Message>,
    pub(crate) body: Accessible,
}

impl AvailableEvent {
    fn registry(&self) -> &Accessible {
        &self.body
    }
}

impl GenericEvent for AvailableEvent {
    /// Bus message.
    #[must_use]
    fn message(&self) -> &Arc<Message> {
        &self.message
    }

    /// The interface that emitted the event.
    #[must_use]
    fn interface(&self) -> Option<InterfaceName<'_>> {
        self.message.interface()
    }

    /// Identifies this event interface's member name.
    #[must_use]
    fn member(&self) -> Option<MemberName<'_>> {
        self.message.member()
    }

    /// The object path to the object where the signal was emitted.
    #[must_use]
    fn path(&self) -> std::option::Option<zbus::zvariant::OwnedObjectPath> {
        Some(OwnedObjectPath::from(self.message.path().unwrap()))
    }

    /// Identifies the `sender` of the event.
    /// # Errors
    /// - when deserializeing the header failed, or
    /// - When `zbus::get_field!` finds that 'sender' is an invalid field.
    fn sender(&self) -> Result<Option<zbus::names::UniqueName>, crate::AtspiError> {
        Ok(self.message.header()?.sender()?.cloned())
    }
}

impl TryFrom<Arc<Message>> for AvailableEvent {
    type Error = AtspiError;

    fn try_from(message: Arc<Message>) -> Result<Self, Self::Error> {
        if message.member() != Some(MemberName::from_static_str("Available")?) {
            return Err(AtspiError::MemberMatch("available".to_string()));
        };
        let body = message.body::<Accessible>()?;
        Ok(Self { message, body })
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct Key {}

#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct KeyStrokeItem {}

impl TryFrom<Arc<Message>> for Event {
    type Error = AtspiError;

    fn try_from(msg: Arc<Message>) -> Result<Event, AtspiError> {
        let body_signature = msg.body_signature()?;
        let message_signature = body_signature.as_str();
        let signal_member = msg
            .member()
            .ok_or(AtspiError::MemberMatch("signal without message".to_string()))?;
        let message_member = signal_member.as_str();

        match message_signature {
            // Accessible signature
            "(so)" => match message_member {
                "RemoveAccessible" => {
                    let ev = CacheRemoveEvent::try_from(msg)?;
                    Ok(Event::Cache(CacheEvent::Remove(ev)))
                }
                "Available" => {
                    let ev = AvailableEvent::try_from(msg)?;
                    Ok(Event::Available(ev))
                }
                _ => Err(AtspiError::UnknownSignal),
            },
            // Atspi / Qspi signature
            "siiva{sv}" | "siiv(so)" => {
                let ev = AtspiEvent::try_from(msg)?;
                Ok(Event::Atspi(ev))
            }
            "(ss)" => {
                if let Ok(ev) = EventListenerRegisteredEvent::try_from(msg.clone()) {
                    return Ok(Event::Listener(EventListenerEvent::Registered(ev)));
                }
                if let Ok(ev) = EventListenerDeregisteredEvent::try_from(msg) {
                    return Ok(Event::Listener(EventListenerEvent::Deregistered(ev)));
                }
                Err(AtspiError::UnknownSignal)
            }
            // CacheAdd signature
            "((so)(so)(so)iiassusau)" => {
                let ev = CacheAddEvent::try_from(msg)?;
                Ok(Event::Cache(CacheEvent::Add(ev)))
            }
            _ => Err(AtspiError::UnknownBusSignature),
        }
    }
}

/// Shared behavior of bus `Signal` events.
pub trait GenericEvent {
    /// Returns the `Message` of the event type.
    fn message(&self) -> &Arc<Message>;
    /// Interface that has the signal member implemented.
    fn interface(&self) -> Option<InterfaceName<'_>>;
    /// Interface member that sent the signal.
    fn member(&self) -> Option<MemberName<'_>>;
    /// Path of the signal.
    /// # Errors
    /// TODO Describe error conditions
    fn path(&self) -> Option<zvariant::OwnedObjectPath>;
    /// Sender of the signal.
    /// # Errors
    /// TODO Describe error conditions
    fn sender(&self) -> Result<Option<UniqueName>, AtspiError>;
}

impl AtspiEvent {
    /// Deserialized signal body type.
    #[must_use]
    pub fn body(&self) -> &EventBodyOwned {
        &self.body
    }

    /// Returns the atspi event string for this event type (E.G. "Object:StateChanged:Focused").
    ///
    /// This should not be used for matching on events as it needlessly allocates and copies the 3
    /// components of the event type. It is meant for logging, etc.
    #[must_use]
    pub fn event_string(&self) -> String {
        let interface = self.message.interface().expect("Event should have an interface");
        let interface = interface.rsplit('.').next().expect("Interface should contain a '.'");
        let member = self.message.member().expect("Event should have a member");
        let kind = self.kind();
        format!("{interface}:{member}:{kind}")
    }

    #[must_use]
    pub fn kind(&self) -> &str {
        &self.body.kind
    }

    /// Event dependant detail.
    #[must_use]
    pub fn detail1(&self) -> i32 {
        self.body.detail1
    }

    /// Event dependant detail.
    #[must_use]
    pub fn detail2(&self) -> i32 {
        self.body.detail2
    }

    /// Event dependant generic `Value`.
    #[must_use]
    pub fn any_data(&self) -> &zvariant::OwnedValue {
        &self.body.any_data
    }

    #[must_use]
    pub fn properties(&self) -> &HashMap<String, zvariant::OwnedValue> {
        &self.body.properties
    }
}
