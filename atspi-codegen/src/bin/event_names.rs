use atspi_codegen::*;

fn iface_name(iface: &Interface) -> String {
	iface.name().split('.').next_back().expect("An interface must have a period in its name.").to_string()
}

fn into_rust_enum_str<S>(string: S) -> String 
	where S: Into<String> {
	// needed to escape the uUShadeEvent
	// make sure Count is its own word
	// make sure Width is its own word
	string.into()
		.replace("uU", "UU")
		.replace("count", "Count")
		.replace("width", "Width")
    //.replace("AddAccessible", "Add")
    //.replace("RemoveAccessible", "Remove")
}

fn events_ident<S>(string: S) -> String
	where S: Into<String> {
	let mut sig_name_event_str = string.into();
	sig_name_event_str.push_str("Events");
	into_rust_enum_str(sig_name_event_str)
}

fn generate_sub_enum_from_interface(interface: &Interface) -> String {
  let last_after_period = iface_name(interface);
  match last_after_period.as_str() {
    "Cache" => "CacheEvents",
    "Socket" => "AvailableEvent",
    "Registry" => "EventListenerEvents",
    // this covers all other cases like Document, Object, etc.
    _ => "EventInterfaces",
  }.to_string()
  
}

fn iface_to_enum_name(interface: &Interface) -> String {
	interface.name().split('.').next_back().expect("Interface must contain a period").to_string()
}

fn generate_variant_from_signal(signal: &Signal) -> String {
	let sig_name = into_rust_enum_str(signal.name());
	format!("\t{sig_name},")
}

fn generate_mod_from_iface(iface: &Interface) -> String {
	let enums = generate_enum_from_iface(iface);
	format!("{enums}")
}

fn generate_enum_from_iface(iface: &Interface) -> String {
  let iface_name = iface.name().clone();
	let name_ident = iface_to_enum_name(iface);
	let name_ident_plural = events_ident(name_ident);
	let signal_quotes = iface.signals()
			.into_iter()
			.map(|signal| generate_variant_from_signal(signal))
			.collect::<Vec<String>>()
			.join("\n");
	format!("#[bitflags]
#[repr(u32)]
#[derive(Clone, Copy, Debug, Serialize, Deserialize, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub enum {name_ident_plural} {{
{signal_quotes}
}}
impl Signal for {name_ident_plural} {{
  const INTERFACE: &'static str = \"{iface_name}\";
}}
")
}

pub fn get_signal_names_from_interfaces(interfaces: Vec<&Interface>) -> String {
	interfaces
		.iter()
		.map(|iface| {
			let mut signal_events_names = iface.signals()
				.iter()
				.map(|signal| signal.name().to_owned() + "Event")
				.collect::<Vec<String>>();
			// if there is only one event, this is probably doesn't need the interface event on top. This is because no enum should be necessary to contain a single type.
			if signal_events_names.len() != 1 {
				let interface_ending = generate_sub_enum_from_interface(iface);
				signal_events_names.push(interface_ending);
			}
			signal_events_names.join(",")
		})
		.collect::<Vec<String>>()
		.join(",")
}

pub fn create_events_from_xml(file_name: &str) -> String {
	let xml_file = std::fs::File::open(file_name).expect("Cannot read file");
	let data: Node = Node::from_reader(&xml_file).expect("Cannot deserialize file");
	let iface_data = data.interfaces()
		.iter()
		.map(|iface| generate_mod_from_iface(iface))
		.collect::<Vec<String>>()
		.join("\n");
  format!("{iface_data}")
}

pub fn main() {
	println!("/// BEWARE: This file has been automatically generated by the `atspi-codegen` crate.
/// Any edits to this file will be overwritten by the next re-generation of this file.

use serde::{{Serialize, Deserialize}};
use enumflags2::bitflags;

pub trait Signal {{
  const INTERFACE: &'static str;
}}
{}", create_events_from_xml("xml/Event.xml"));
  println!("{}", create_events_from_xml("xml/Cache.xml"));
}
